{% from 'utils/code_block.html' import code_block %}
{% from 'utils/content_table.html' import table %}

<p>Анимации в Qt — мощный инструмент для создания визуальных эффектов.
</p>
<h1 id="animations">Анимации</h1>
<p>Для того, чтобы сделать анимацию, используется объект <code>QPropertyAnimation</code>.
Для его инициализации необходимо указать:</p>
<ul>
    <li>Объект, которй мы хотим анимировать</li>
    <li>Свойство объекта, которое мы хотим анимировать</li>
    <li>Родителя анимации</li>
</ul>
<p>Свойство объекта предоставляется в виде байт-строки. Оно может быть
следующих типов:</p>
<ul>
    <li>int</li>
    <li>float</li>
    <li>QPoint</li>
    <li>QRect</li>
    <li>QSize</li>
    <li>QColor</li>
</ul>
<p>После инициализации нам надо:</p>
<ol>
    <li>Задать стартовое значение: <code>anim.setStartValue()</code></li>
    <li>Задать конечное значение: <code>anim.setEndValue()</code></li>
    <li>Задать продолжительность: <code>anim.setDuration(ms)</code></li>
</ol>
<p>А также при необходимости:</p>
<ul>
    <li>Задать кривую анимации: <code>anim.setEasingCurve(QEasingCurve)</code></li>
    <li>Задать количество повторений: <code>anim.setLoopCount()</code>; 0 для бесконечного цикла</li>
    <li>Законнектить анимацию к функции: <code>anim.finish.connect(func)</code></li>
</ul>
<p>Теперь у нас есть объект anim. И при необходимости в нужный момент мы можем
запустить анимацию: <code>anim.start()</code></p>
<p>Но есть один нюанс: после того, как анимация запустилась, она уже как бы не нужна,
поэтому сборщик мусора в питоне может удалить ее, хотя анимация еще не проигралоась
полностью. Поэтому анимации надо сохранять. Либо в атрибут self, либо в список,
либо еще куда то.</p>
<h1 id="animations_group">Группы анимаций</h1>
<p>Анимации можно объединять в группы. Группы также, как и анимации
можно запускать, коннектить при завершении к функции, и проч. Существуют
два типа групп:</p>
<ul>
    <li><code>QParallelAnimationGroup()</code>: группа анимаций, выполняющихся параллельно</li>
    <li><code>QSequentialAnimationGroup()</code>: группа анимаций, выполняющихся последовательно</li>
</ul>
<p>Анимации в группу можно добавить с помощью метода <code>group.addAnimation(anim)</code></p>
<h1 id="anim_example">Пример анимации</h1>
<p>Давайте немного изменим наш проект, добавим анимации "нажатия" к кнопкам</p>
<p>Для начала напишем класс, который заменит нам обычные кнопки:</p>
{{ code_block(PressableButtonWidget) }}
<p>Теперь возникает проблема: если бы у нас не было компоновщика, то мы бы
просто изменили бы класс кнопок на PressableButtonWidget. Но так как компоновщик
сам решает, какого размера будут его виджеты, то анимация размера будет играться некорректно.
Придется чуть повозиться: мы обернем кнопки в QWidget, и анимация будет идти
внутри него корректно, так как мы не будем добавлять в него компоновщик</p>
<p>Изменим методы, которые делают кнопку у главного окна:</p>
{{ code_block(do_click_button) }}
{{ code_block(do_reset_button) }}
<p>Еще немного про размеры: не забывайте, что анимация будет отрисовываться только
внутри родительского объекта. Так что, если бы у нас была анимация расширения
виджета сначала, то пришлось бы сделать родительский виджет чуть больше,
чтобы анимация корректно проигрывалась.</p>
<h1 id="properties">Анимируемые свойства</h1>
<p>Как вы помните, мы можем анимировать свойства. А что, если нужного нам свойства нет у виджета?
Мы можем его сделать самостоятельно</p>
<p>Для этого необходимо создать свойство в теле класса, а затем написать
его getter и setter. Все!</p>
{{ code_block(custom_property) }}
<p>Теперь мы сможем передать свойство b'value' в качестве параметра в анимацию.
Я создавал собственную анимацию, когда анимировал цвет бордера у ячейки.
В геттере я просто возвращал значение self.border_color, а в сеттере менял стили (о стилях позже).
И у меня была рабочая анимация изменения цвета бордера</p>