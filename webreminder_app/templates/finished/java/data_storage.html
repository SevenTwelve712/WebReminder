{% from 'utils/code_block.html' import code_block %}
{% from 'utils/content_table.html' import table %}

<h1 id="arrays">Массивы</h1>
<p>Встроенный в java тип данных, создает массив фиксированной длины</p>
{{ code_block(arrays) }}

<h1 id="collections">Коллекции</h1>
<p>Массивами пользоваться неудобно, поэтому создали коллекции. Они все реализуют интерфейс Collections и наследуются от каких-то своих
абстрактных классов. Коллекции не обладают фиксированным размером, они могут расширяться</p>
<p>Реализуемые интерфейсы:</p>
<ul>
    <li>Collection: базовый интерфейс для всех коллекций и других интерфейсов коллекций</li>
    <li>Queue: наследует интерфейс Collection и представляет функционал для структур данных в виде очереди</li>
    <li>Deque: наследует интерфейс Queue и представляет функционал для двунаправленных очередей</li>
    <li>List: наследует интерфейс Collection и представляет функциональность простых списков</li>
    <li>Set: также расширяет интерфейс Collection и используется для хранения множеств уникальных объектов</li>
    <li>SortedSet: расширяет интерфейс Set для создания сортированных коллекций</li>
    <li>NavigableSet: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию</li>
    <li>Map: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection</li>
</ul>
<p>Реализация интерфейсов (частичная) абстрактными классами:</p>
<ul>
    <li>AbstractCollection: базовый абстрактный класс для других коллекций, который применяет интерфейс Collection</li>
    <li>AbstractList: расширяет класс AbstractCollection и применяет интерфейс List, предназначен для создания коллекций в виде списков</li>
    <li>AbstractSet: расширяет класс AbstractCollection и применяет интерфейс Set для создания коллекций в виде множеств</li>
    <li>AbstractQueue: расширяет класс AbstractCollection и применяет интерфейс Queue, предназначен для создания коллекций в виде очередей и стеков</li>
    <li>AbstractSequentialList: также расширяет класс AbstractList и реализует интерфейс List. Используется для создания связанных списков</li>
    <li>AbstractMap: применяет интерфейс Map, предназначен для создания наборов по типу словаря с объектами в виде пары "ключ-значение"</li>
</ul>

<p>Методы Collection:</p>
{{ table(CollectionMethods) }}

<h1 id="arrayList">ArrayList</h1>
<p>Класс простого списка</p>
{{ code_block(arrayList) }}
<p>кроме того можно применять еще конструкторы:</p>
<ul>
    <li><code>ArrayList()</code>: создаст пустой список</li>
    <li><code>ArrayList(Collection &lt;? extends E&gt; col)</code>: создаст список, в который будут добавлены все элементы коллекции</li>
    <li><code>ArrayList(int capacity)</code>: создает список с начальной вместимостью capacity</li>
</ul>
<p>Некоторые его полезные методы (помимо дефолтных)</p>
{{ table(arrayListMethods) }}

<h1 id="ArrayQueue">ArrayDeque</h1>
<p>Является двунаправленной очередью, реализует интерфейс Deque</p>
<p>Конструкторы:</p>
<ul>
    <li><code>ArrayDeque()</code>: создает пустую очередь</li>
    <li><code>ArrayDeque(Collection &lt;? extends E&gt; col)</code>: создаст очередь, в который будут добавлены все элементы коллекции</li>
    <li><code>ArrayDeque(int capacity)</code>: создает очередь с начальной вместимостью capacity</li>
</ul>
<p>Полезные методы:</p>
{{ table(ArrayDequeMethods) }}
<p>Когда работаем как с очередью (FIFO) используем offer() и poll().</p>
<p>Когда работаем как со стеком (LIFO) используем push() и pop()</p>

<h1 id="hashSet">HashSet</h1>
<p>Представляет собой неупорядоченное множество уникальных элементов, основанное на хэш-таблице</p>
{{ code_block(HashSet) }}

<p>HashSet не добавляет своих методов, только переопределяет методы Collection</p>

<h1 id="HashMap">HashMap</h1>
<p>HashMap реализует интерфейс Map&lt;K, V&gt;, наследуется от AbstractMap и является словарем.</p>
<p>Инициализация пустого словаря:</p>
{{ code_block(HashMap) }}
<p>Некоторые методы интерфейса Map:</p>
{{ table(MapMethods) }}

<h1 id="Iterators">Итераторы</h1>
<p>У класса <code>Collection</code> есть метод Iterator&lt;E&gt; iterator(). Он возвращает объект итератора, который умеет:</p>
<ul>
    <li><code>.next()</code>: возвращает следующий элемент или генерит NoSuchElementException</li>
    <li><code>.hasNext()</code>: возвращает true/false (есть ли следующий элемент или нет)</li>
    <li><code>.remove()</code>: удаляет текущий элемент из коллекции, полученный последним вызовом next()</li>
</ul>