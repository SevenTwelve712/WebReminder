{% from 'utils/code_block.html' import code_block %}

<h1 id="class">Класс</h1>
<p>Класс — ключевое понятие в Java. Его можно определить так:</p>
{{ code_block(class_) }}
<p>Внутри класса он сам доступен через ключевое слово <code>this</code></p>

<h1 id="methods">Методы</h1>
<p>У класса должны быть методы, сам по себе он бесполезен.</p>
{{ code_block(methods) }}
<p>причем если мы не знаем, сколько аргументов, их можно указать так: <code>...some_args</code>. В <code>some_args</code> будет массив аргументов, он может
быть пустым.</p>

<h1 id="access">Модификаторы доступа</h1>
<p>Модификатор доступа можно задать как для класса, так и для полей и методов класса. Существующие модификаторы:</p>
<ul>
    <li>public: виден всем</li>
    <li>private: виден только внутри себя</li>
    <li>protected: виден внутри себя, внутри текущего пакета и внутри наследников (даже в других пакетах)</li>
    <li>default: устанавливается, если мы не указали модификатор; вмден всем классам в текущем пакете</li>
</ul>
<p>Мы не можем сужать область видимости, только расширять.</p>

<h1 id="static">Статический контент</h1>
<p>В классе могут быть определены статические инициализаторы, поля и методы. Такие атрибуты класса будут загружаться один раз, ведь они не зависят
от объекта класса.</p>
<p><code>static final double PI = 3.1415;</code></p>

<h1 id="initialization">Инициализация</h1>
<h2 id="constructors">Конструкторы</h2>
<p>Специальный метод, вызывающийся при инициализации класса</p>
{{ code_block(constructor) }}
<h2 id="initializatior">Инициализаторы</h2>
<p>обычный инициализатор. Будет вызываться каждый раз до конструктора.</p>
{{ code_block(initialization) }}

<h1 id="packages">Пакеты</h1>
<p>классы можно объединять пакеты (типа как модули в питоне), для этого в начале файла необходимо указать <code>package <i>package_name</i>;</code></p>

<h1 id="inner_classes">Вложенные классы</h1>
<p>Мы можем определить класс внутри другого класса. Тогда объекты этого класса можно будет создавать только в теле родителя.</p>

<h1 id="extending">Наследование</h1>
<p>Наследовать классы можно с помощью ключевого слова <code>extends</code>:</p>
<p><code>class Person extends Creation {}</code></p>
<p>Можно наследоваться только от одного класса.</p>
<p>Если в базовом классе определены конструкторы, то обязательно в конструкторе наследника вызвать <code>super()</code></p>
<p>при переопределении метода можно указать <code>@Override</code>, но в целом необязательно</p>
<p>Необходимо помнить, что при переопределении чего-либо мы не можем сужать область видимости.</p>

<h1 id="abstract">Абстрактные классы</h1>
<p>Служат для создания основы для классов наследников.</p>
{{code_block(abstract) }}
<p>Мы не можем использовать конструктор абстрактного класса для создания его объекта.</p>
<p>Помимо обычных методов абстрактный класс может содержать абстрактные, причем если класс содержит абстрактный метод, то он обязан быть абстрактным:</p>
<p><code>public abstract void display();</code></p>
<p>Классы наследники (если они не абстрактные) обязаны реализовать этот абстрактный метод.</p>

<h1 id="interfaces">Интерфейсы</h1>
<p>Интерфейсы призваны для того, чтобы задать поведение класса. Они определяют функционал, который класс затем реалитзует. Если класс не абстрактный,
то он обязан реализовать функционал интерфейса</p>
<p>Наследовать класс от интерфейса можно с помощью ключевого слова <code>implements</code>:</p>
<p><code>class Array implements Iterable {}</code></p>
<p>Можно наследоваться от нескольких интерфейсов, в отличие от классов</p>
<p>Как создать интерфейс:</p>
{{ code_block(interface) }}
<p>Начиная с JDK8 можно реализовывать дефолтное поведение методов интерфейса, если они не были реализованы в наследнике. Для обозначения метода как
дефолтного необходимо указать ключевое слово <code>default</code>:</p>
<p><code>default void print() { System.out.println("Print undefined"); }</code></p>
<p>В интерфейсе можно создавать приватные методы. Такие методы будут доступны только в самом интерфейсе, их не нужно реализовывать в наследниках.</p>

<h1 id="enums">Перечисления</h1>
<p>Еще один инструмент в Java</p>
{{ code_block(enums) }}
<p>Каждое перечисление имеет метод <code>.value()</code>, возвращающие массив всех констант перечисления</p>
<p>кроме того можно получить порядковый номер определенной константы с помощью метода <code>.ordinal()</code>. нумерация констант идет  с 0</p>
<p>Также можно определять конструктор для перечисления, но этот конструктор будет private, и использовать его мы сможем только в самом перечислении:</p>
{{ code_block(enum_constr) }}
<p>Помимо этого в перечислении можно реализовывать какие-либо методы, в том числе для отдельных констант:</p>
{{ code_block(const_methods) }}

<h1 id="generics">Обобщения</h1>
<p>Если мы не знаем, какой тип данных будет использоваться, мы можем использовать обобщение: </p>
{{ code_block(generic) }}
<p>Обобщение может использоваться в интерфейсах, методах, конструкторах и проч.</p>

<h1 id="records">Записи</h1>
<p>Records представляют классы, которые предназначены для создания контейнеров неизменяемых данных:</p>
{{ code_block(records) }}
<p>Также мы можем переопределять методы записей</p>