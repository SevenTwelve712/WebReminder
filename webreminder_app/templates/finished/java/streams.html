{% from 'utils/code_block.html' import code_block %}
{% from 'utils/content_table.html' import table %}

<h1 id="base_streams">Базовые потоки</h1>
<p>В java потоки делятся в основном на два типа:</p>
<ul>
  <li>байтовые: представлены абстрактными классами <code>InputStream</code> и <code>OutputStream</code></li>
  <li>символьные: представлены абстрактными классами <code>Reader</code> и <code>Writer</code></li>
</ul>
<p>Символьные потоки наследуются от байтовых, все остальные потоки наследуются от этих четырех.</p>
<p>Кроме того, потоки при инициализации объекта могут выкинуть IOException, поэтому надо либо обрабатывать его при помощи try-with-resources, либо с помощью
обычного try-catch, но в таком случае надо не забыть закрыть поток в finally</p>
<p>Возможности потоков:</p>
{{ table(baseStreamsMethods) }}

<h1 id="file_streams">Файловые потоки</h1>
<p>Здесь рассмотрим потоки для работы с файлами. Мы будем их использовать только с другими потоками</p>
<h2 id="FileInputStream">FileInputStream</h2>
<p>Предназначен для байтовой записи в файл. Конструкторы:</p>
{{ code_block(FISConstr) }}

<h2 id="FileOutputStream">FileOutputStream</h2>
<p>Предназначен для считывания байтов из файла. Конструкторы:</p>
{{ code_block(FOSConstructor) }}
<p>Можно указывать второй параметр <code>append</code> для дозаписи в файл, если append == false (default), то файл перезапишется</p>

<h2 id="FileReader">FileReader</h2>
<p>Предназначен для считывания текста из файла. Конструкторы:</p>
{{ code_block(FRConstructor) }}

<h2 id="FileWriter">FileWriter</h2>
<p>Предназначен для записывания символов в файл. Конструкторы:</p>
{{ code_block(FWConstructor) }}
<p>Опять же, можно указать второй параметр <code>append</code></p>

<h1 id="buffered_streams">Буферизованные потоки</h1>
<p>Буферизованные потоки призваны для оптимизации обычных потоков, они работают как обертки над ними</p>
<ul>
    <li>Буферизованный поток чтения считывает информацию большими порциями в буфер, а затем отдает символы/байты по запросу</li>
    <li>
        Данные, поступающие в буферизованный поток ввода записываются во внутренний буфер, который записывается в файл при:
        <ol>
            <li>переполнении буфера</li>
            <li>ручном очищении .flush()</li>
            <li>закрытии потока .close()</li>
        </ol>
    </li>
</ul>
<p>Общий конструктор для буферизованного потока:</p>
{{ code_block('BufferedStream(Stream stream, int sz) throws IOException') }}
<p>Где sz — размер в символах/байтах (зависит от передаваемого потока stream)</p>
<p>конкретные конструкторы:</p>
<ul>
    <li><code>BufferedInputStream(InputStream inputStream, int bufSize)</code></li>
    <li><code>BufferedOutputStream(OutputStream outputStream, int bufSize)</code></li>
    <li><code>BufferedWriter(Writer out, int sz)</code></li>
    <li><code>BufferedReader(Reader in, int sz) </code></li>
</ul>
<p>Естественно, в буферизованный поток можно передавать не только базовые потоки, но и их наследников</p>
<p>Некоторые полезные методы буферизованных потоков:</p>
 {{ table(BufferedStreamsMethods) }}

<h1 id="reading">Текстовое чтение из файла</h1>
<p>Для чтения из файла (или потока) используем объект Scanner, позволяющий удобно считывать различные типы данных, в который передадим FileReader:</p>
{{ code_block(Scanner) }}

<p>Или же оборачиваем в буферизованный поток и считываем построчно, но тогда придется пожертвовать удобством :</p>
{{ code_block(BufferedReader) }}

<h1 id="writing">Текстовая запись в файл</h1>
<p>Для записи используем поток PrintWriter, в который передадим FileWriter:</p>
{{ code_block(PrintWriter) }}
<p>Для большей производительности можем обернуть FileWriter в BufferedWriter и затем буферизованный поток передать в PrintWriter</p>
<p>Некоторые полезные методы PrintWriter</p>
{{ table(PrintWriterMethods) }}

<h1 id="serialization">Сериализация объектов</h1>
<p>Сериализация — запись объекта в поток. Для того чтобы объект можно было сериализовать, он должен реализовывать интерфейс Serializable.
Сам интерфейс не определяет никаких методов, он просто указывает на то, что объект можно сериализовать</p>
<p>При сериализации записывается полная структура класса. (поля, ссылки, итд). Если мы не хотим, чтобы поле записывалось при сериализации ,нужно
пометить его как <code>transient</code>:</p>
{{ code_block('private transient int counter;') }}
<h2 id="ObjectOutputStream">ObjectOutputStream</h2>
<p>Используется для сериализации объектов. Конструктор:</p>
{{ code_block('ObjectOutputStream(OutputStream out)') }}
<p>Некоторые полезные методы:</p>
{{ table(OSTable) }}
<p>Стоит учесть, что при записи ObjectOutputStream пишет специальный заголовок, необходимый для десериализации,
    поэтому обычным способом дозаписывать не получится.</p>

<h2 id="ObjectInputStream">ObjectInputStream</h2>
<p>Используется для десериализации объектов. Конструктор:</p>
{{ code_block('ObjectInputStream(InputStream in)') }}
<p>Некоторые полезные методы:</p>
{{ table(ISTable) }}
