{% from 'utils/code_block.html' import code_block %}
{% from 'utils/content_table.html' import table %}

<h1 id="item">Класс Item</h1>
<h2 id="constructor">Конструктор</h2>
<code>new Item(new Item.Properties())</code>
<p>Properties — это параметры предмета, определяющие его. Вот список некоторых полезных параметров:</p>
{{ table(properties) }}
<p>параметры прописываются как методы Properties, например: <code>Item.Properties().durability(540)</code></p>

<h2 id="methods">Методы</h2>
<p>Методы, переопределяющие поведение предмета:</p>

<h3 id="useOn">.useOn</h3>
<p>Принимает <code>UseOnContext pContext</code>, вызывается при пкм с предметом в руке</p>
<p>полезные методы pContext:</p>
{{ table(UseOnContext) }}
<p>Примечания при работе:</p>
<ul>
    <li>Различай clientSide и serverSide при работе с Level. Изменения блоков/сущностей и проч. должны происходить на сервере, а частицы/визуальные эффекты на клиенте.
     Проверяй <code>level.isClientSide()</code>, или что-то подобное</li>
</ul>

<h3 id="getUseAnimation">.getUseAnimation</h3>
<p>Принимает <code>ItemStack</code>, нужно вернуть анимацию для него при использовании</p>
<p>Полезно, например, если мы хотим переопределить дефолтную анимацию еду на питье:</p>
{{ code_block(getUseAnimation) }}

<h3 id="getBurnTime">.getBurnTime</h3>
<p><code>public int getBurnTime(ItemStack itemStack, @Nullable RecipeType<?> recipeType)</code></p>
<p>Нужно вернуть время горения предмета в тиках, полезно для топлива.</p>

<h3 id="appendHoverText">.appendHoverText</h3>
<p><code>public void appendHoverText(ItemStack pStack, Item.TooltipContext pContext, List&gt;Component&lt; pTooltipComponents, TooltipFlag pTooltipFlag)</code></p>
<p>Добавляет подсказку к предмету при наведении:</p>
<p><code>pTooltipComponents.add(Component.translatable("tooltip_id, for example tooltip.mod_id.tooltip_id"));</code>. Теперь осталось прописать перевод для этого id в lang</p>
<p>Каждый новый вызов .add добавляет новую строку. Также можно проверять условие <code>Screen.isShiftDown</code>, чтобы возвращать
соответствующий контент при зажатом шифте</p>

<h2 id="useful_code">Примеры полезного кода</h2>
<h3 id="simple_item_registration">Регистрация простого предмета</h3>
{{ code_block('ITEMS.register("item_id", () -> new Item(new Item.Properties()));') }}

<h3 id="custom_item_constr">Базовый класс кастомного класса для предмета</h3>
{{ code_block(custom_item_base) }}


<h1 id="ItemStack">Класс ItemStack</h1>
<p>Класс, который отвечает за конкретное состояние предмета в игре. Например, его объект мы получаем при вызове <code>player.getItemInHand(HAND)</code></p>
<p>Таблица полезных методов получения информации:</p>
{{ table(ItemStackMethods) }}

<h2 id="useful_code_itemstack">Полезный код</h2>
<h3 id="hurtAndBreak">hurtAndBreak</h3>
{{ code_block('pContext.getItemInHand().hurtAndBreak(1, ((ServerLevel) level), (ServerPlayer) pContext.getPlayer(),
item -> pContext.getPlayer().onEquippedItemBroken(item, EquipmentSlot.MAINHAND));') }}

<h1 id="extends">Классы наследники Item</h1>
<p>У Item есть несколько полезных классов наследников, реализующих необходимый функционал:</p>
{{ table(ItemExtends) }}

<h1 id="representation">Отображение в игре</h1>
<p>прежде всего, не забываем добавить наш предмет в <code>resources/assets/mod_id/lang/en_us.json</code>. Указываем
    <code>"item.mod_id.item_id": "translation"</code></p>
<h2 id="model">Добавляем модель</h2>
<p>Модель стоит добавлять в <code>assets/mod_id/model/item/item_id.json</code>. Возможно, тут позже будет разбор этого файла, но на данный момент просто забиваем
туда содержание:</p>
{{ code_block(item_model) }}

<h2 id="texture">Текстура</h2>
<p>Текстуру в формате .png добавляем в <code>assets/mod_id/textures/item/item_id.png</code></p>